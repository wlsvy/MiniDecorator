using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;
using System;
using System.Collections.Concurrent;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using Humanizer;
using System.Collections.Generic;
using System.Collections.Immutable;

namespace MiniDecorator;

public abstract class DecoratorBaseAttribute(string template) : Attribute;

[Generator]
public class DecoratorSourceGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        // Step 1: Find all classes that inherit from DecorateBaseAttribute
        var decoratorAttributeTypes = context.SyntaxProvider
            .CreateSyntaxProvider(
                predicate: static (s, _) => IsAttributeClass(s),
                transform: static (ctx, _) => GetSemanticTargetForDecoratorAttribute(ctx))
            .Where(static m => m != null)
            .Collect();

        // Step 2: Find all methods decorated with any of the decorator attributes
        var methodsWithDecorator = context.SyntaxProvider
            .CreateSyntaxProvider(
                predicate: static (s, _) => IsMethodWithAttribute(s),
                transform: static (ctx, _) => GetMethodWithDecorator(ctx))
            .Where(static m => m != default)
            .Collect();

        // Combine the collected decorator attributes and methods
        context.RegisterSourceOutput(
            decoratorAttributeTypes.Combine(methodsWithDecorator),
            (spc, source) => Execute(source.Left, source.Right, spc));
    }

    private void Execute(
        ImmutableArray<INamedTypeSymbol> decoratorAttributes,
        ImmutableArray<(IMethodSymbol MethodSymbol, INamedTypeSymbol AttributeSymbol)> methods,
        SourceProductionContext context)
    {
        if (decoratorAttributes.IsDefaultOrEmpty)
        {
            return;
        }

        if (methods.IsDefaultOrEmpty)
        {
            return;
        }

        // Map decorator attribute names to their template strings
        var decoratorTemplates = new Dictionary<string, string>();

        foreach (INamedTypeSymbol? decorator in decoratorAttributes)
        {
            // Get the 'template' constructor argument
            var template = decorator
                .GetAttributes()
                .FirstOrDefault(attr => attr.AttributeClass.Name == "DecorateBaseAttribute")?
                .ConstructorArguments
                .FirstOrDefault().Value as string;

            if (!string.IsNullOrEmpty(template))
            {
                decoratorTemplates[decorator.Name] = template;
            }
        }

        // StringBuilder to accumulate the generated methods
        var sb = new StringBuilder();
        sb.AppendLine("// <auto-generated />");
        sb.AppendLine("using System;");
        sb.AppendLine();
        sb.AppendLine("namespace GeneratedDecorators");
        sb.AppendLine("{");

        foreach (var (methodSymbol, attributeSymbol) in methods)
        {
            if (!decoratorTemplates.TryGetValue(attributeSymbol.Name, out var template))
                continue;

            // Extract method details
            var methodName = methodSymbol.Name;
            var returnType = methodSymbol.ReturnType.ToDisplayString(SymbolDisplayFormat.MinimallyQualifiedFormat);
            var parametersWithType = string.Join(", ", methodSymbol.Parameters.Select(p => $"{p.Type.ToDisplayString(SymbolDisplayFormat.MinimallyQualifiedFormat)} {p.Name}"));
            var parameterList = string.Join(", ", methodSymbol.Parameters.Select(p => p.Name));

            // Replace placeholders in the template
            var processedMethod = template
                .Replace("{{DecoratorTemplate.MethodName}}", methodName)
                .Replace("{{DecoratorTemplate.ReturnType}}", returnType)
                .Replace("{{DecoratorTemplate.ParameterListWithType}}", parametersWithType)
                .Replace("{{DecoratorTemplate.ParameterList}}", parameterList);

            sb.AppendLine(processedMethod);
            sb.AppendLine();
        }

        sb.AppendLine("}"); // End of namespace

        // Add the generated source
        context.AddSource("GeneratedDecorators.g.cs", SourceText.From(sb.ToString(), Encoding.UTF8));
    }

    // Helper method to check if the syntax node is a class that could be an attribute
    private static bool IsAttributeClass(SyntaxNode node)
    {
        return node is ClassDeclarationSyntax cds && cds.BaseList != null;
    }

    // Transform method to get the decorator attribute type symbol
    private static INamedTypeSymbol GetSemanticTargetForDecoratorAttribute(GeneratorSyntaxContext context)
    {
        var classDeclaration = (ClassDeclarationSyntax)context.Node;

        // Look for classes that inherit from DecorateBaseAttribute
        foreach (BaseTypeSyntax baseType in classDeclaration.BaseList.Types)
        {
            INamedTypeSymbol? typeSymbol = context.SemanticModel.GetTypeInfo(baseType.Type).Type as INamedTypeSymbol;
            if (typeSymbol == null)
            {
                continue;
            }

            if (typeSymbol.ToDisplayString() == nameof(DecorateBaseAttribute))
            {
                return context.SemanticModel.GetDeclaredSymbol(classDeclaration) as INamedTypeSymbol;
            }
        }

        return null;
    }

    // Helper method to check if the syntax node is a method with at least one attribute
    private static bool IsMethodWithAttribute(SyntaxNode node)
    {
        return node is MethodDeclarationSyntax mds && mds.AttributeLists.Count > 0;
    }

    // Transform method to get the method symbol and its decorator attribute symbol
    private static (IMethodSymbol MethodSymbol, INamedTypeSymbol AttributeSymbol) GetMethodWithDecorator(GeneratorSyntaxContext context)
    {
        var methodDeclaration = (MethodDeclarationSyntax)context.Node;
        var methodSymbol = context.SemanticModel.GetDeclaredSymbol(methodDeclaration) as IMethodSymbol;

        if (methodSymbol == null)
            return (null, null);

        foreach (var attributeData in methodSymbol.GetAttributes())
        {
            var attrClass = attributeData.AttributeClass;
            if (attrClass == null)
                continue;

            // Check if the attribute inherits from DecorateBaseAttribute
            var baseType = attrClass.BaseType;
            while (baseType != null)
            {
                if (baseType.Name == "DecorateBaseAttribute")
                    return (methodSymbol, attrClass);
                baseType = baseType.BaseType;
            }
        }

        return (null, null);
    }
}

[Generator]
public class AutoNotifyGenerator : ISourceGenerator
{
    public void Initialize(GeneratorInitializationContext context)
    {
        // 초기화 단계에서는 별도 작업이 필요하지 않습니다.
    }

    public void Execute(GeneratorExecutionContext context)
    {
        // 모든 SyntaxTree를 가져옵니다.
        SyntaxTree[] syntaxTrees = context.Compilation.SyntaxTrees.ToArray();

        // 병렬 처리 결과를 저장할 ConcurrentBag
        ConcurrentBag<(string fileName, string code)> generatedCodes = new();

        // 병렬 처리로 각 SyntaxTree를 분석
        Parallel.ForEach(syntaxTrees, syntaxTree =>
        {
            SyntaxNode root = syntaxTree.GetRoot();
            // 클래스 선언을 가져오고 그 안에 모든 멤버를 조회
            var classDeclarations = root.DescendantNodes()
                .OfType<ClassDeclarationSyntax>()
                .SelectMany(classDecl => classDecl.Members
                    .Select(member => (classDecl, member)));

            foreach (var (classDeclaration, member) in classDeclarations)
            {
                if (member is not FieldDeclarationSyntax fieldDeclaration)
                {
                    continue;
                }
                
                foreach (VariableDeclaratorSyntax variable in fieldDeclaration.Declaration.Variables)
                {
                    // 필드에 [AutoNotify] 속성이 있는지 확인
                    if (fieldDeclaration.AttributeLists.Any(attrList => attrList.Attributes.Any(attr => attr.ToString().Contains("AutoNotify"))))
                    {
                        // 클래스 및 필드 이름 추출
                        string className = classDeclaration.Identifier.Text;
                        string fieldName = variable.Identifier.Text;
                        string propertyName = fieldName.Pascalize();

                        string generatedCode = $$"""
                                         namespace {{context.Compilation.AssemblyName}}
                                         {
                                             public partial class {{className}}
                                             {
                                                 public {{fieldDeclaration.Declaration.Type}} {{propertyName}}
                                                 {
                                                     get => {{fieldName}};
                                                     set
                                                     {
                                                         if (!Equals({{fieldName}}, value))
                                                         {
                                                             {{fieldName}} = value;
                                                             OnPropertyChanged(nameof({{propertyName}}));
                                                         }
                                                     }
                                                 }
                                         
                                                 private void OnPropertyChanged(string propertyName)
                                                 {
                                                     // PropertyChanged 이벤트를 호출하는 코드가 여기에 위치할 수 있습니다.
                                                 }
                                             }
                                         }
                                         """;

                        // 결과를 ConcurrentBag에 저장
                        generatedCodes.Add(($"{className}_{fieldName}_AutoNotify.cs", generatedCode));
                    }
                }
            }
        });

        // 병렬 처리 후 context에 코드 추가
        foreach (var (fileName, code) in generatedCodes)
        {
            context.AddSource(fileName, SourceText.From(code, Encoding.UTF8));
        }
    }
}